'use strict';
sap.ui.define([
    'open/ux/preview/client/thirdparty/@sap-ux-private/control-property-editor-common',
    './flex-change',
    'sap/base/Log',
    '../rta-service',
    '../../utils/error',
    'sap/m/MessageToast',
    '../../i18n'
], function (___sap_ux_private_control_property_editor_common, ___flex_change, Log, ___rta_service, ____utils_error, MessageToast, ____i18n) {
    'use strict';
    const changeProperty = ___sap_ux_private_control_property_editor_common['changeProperty'];
    const changeStackModified = ___sap_ux_private_control_property_editor_common['changeStackModified'];
    const deletePropertyChanges = ___sap_ux_private_control_property_editor_common['deletePropertyChanges'];
    const propertyChangeFailed = ___sap_ux_private_control_property_editor_common['propertyChangeFailed'];
    const FlexChangesEndPoints = ___sap_ux_private_control_property_editor_common['FlexChangesEndPoints'];
    const reloadApplication = ___sap_ux_private_control_property_editor_common['reloadApplication'];
    const setApplicationRequiresReload = ___sap_ux_private_control_property_editor_common['setApplicationRequiresReload'];
    const save = ___sap_ux_private_control_property_editor_common['save'];
    const applyChange = ___flex_change['applyChange'];
    const modeAndStackChangeHandler = ___rta_service['modeAndStackChangeHandler'];
    const getError = ____utils_error['getError'];
    const getTextBundle = ____i18n['getTextBundle'];
    function assertProperties(properties, target) {
        for (const property of properties) {
            const value = target[property];
            if (value === null || value === undefined) {
                throw new Error(`Invalid change, missing ${ property } in the change file`);
            }
        }
    }
    function assertChange(change) {
        assertProperties([
            'fileName',
            'selector',
            'content',
            'creation'
        ], change);
        assertProperties(['id'], change.selector);
        assertProperties(['property'], change.content);
    }
    function modifyRTAErrorMessage(errorMessage, id, type) {
        return errorMessage.replace('Error: Applying property changes failed:', '').replace(`${ type }#${ id }`, '');
    }
    class ChangeService {
        savedChanges = [];
        changesRequiringReload = 0;
        constructor(options, selectionService) {
            this.options = options;
            this.selectionService = selectionService;
        }
        async init(sendAction, subscribe) {
            this.sendAction = sendAction;
            subscribe(async action => {
                if (changeProperty.match(action)) {
                    try {
                        this.selectionService.applyControlPropertyChange(action.payload.controlId, action.payload.propertyName);
                        await applyChange(this.options, action.payload);
                    } catch (exception) {
                        let name = '';
                        const id = action.payload.controlId || '';
                        const control = sap.ui.getCore().byId(id);
                        if (control) {
                            name = control.getMetadata().getName();
                        }
                        const error = getError(exception);
                        const modifiedMessage = modifyRTAErrorMessage(error.toString(), id, name);
                        const errorMessage = modifiedMessage || `RTA Exception applying expression "${ action.payload.value }"`;
                        const propertyChangeFailedAction = propertyChangeFailed({
                            ...action.payload,
                            errorMessage
                        });
                        sendAction(propertyChangeFailedAction);
                    }
                } else if (deletePropertyChanges.match(action)) {
                    await this.deleteChange(action.payload.controlId, action.payload.propertyName, action.payload.fileName);
                } else if (reloadApplication.match(action)) {
                    this.sendAction(setApplicationRequiresReload(false));
                } else if (save.match(action)) {
                    this.changesRequiringReload = 0;
                    this.sendAction(setApplicationRequiresReload(false));
                }
            });
            await this.fetchSavedChanges();
            this.updateStack();
            this.options.rta.attachUndoRedoStackModified(this.createOnStackChangeHandler());
        }
        updateStack() {
            let pendingChanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            this.sendAction(changeStackModified({
                saved: this.savedChanges,
                pending: pendingChanges
            }));
        }
        async fetchSavedChanges() {
            const savedChangesResponse = await fetch(FlexChangesEndPoints.changes + `?_=${ Date.now() }`);
            const savedChanges = await savedChangesResponse.json();
            const changes = Object.keys(savedChanges ?? {}).map(key => {
                const change = savedChanges[key];
                try {
                    assertChange(change);
                    if ([
                            change.content.newValue,
                            change.content.newBinding
                        ].every(item => item === undefined || item === null)) {
                        throw new Error('Invalid change, missing new value in the change file');
                    }
                    if (change.changeType !== 'propertyChange' && change.changeType !== 'propertyBindingChange') {
                        throw new Error('Unknown Change Type');
                    }
                    return {
                        type: 'saved',
                        kind: 'property',
                        fileName: change.fileName,
                        controlId: change.selector.id,
                        propertyName: change.content.property,
                        value: change.content.newValue ?? change.content.newBinding,
                        timestamp: new Date(change.creation).getTime(),
                        controlName: change.selector.type ? change.selector.type.split('.').pop() : '',
                        changeType: change.changeType
                    };
                } catch (error) {
                    if (change.fileName) {
                        const unknownChange = {
                            type: 'saved',
                            kind: 'unknown',
                            changeType: change.changeType,
                            fileName: change.fileName,
                            controlId: change.selector?.id
                        };
                        if (change.creation) {
                            unknownChange.timestamp = new Date(change.creation).getTime();
                        }
                        return unknownChange;
                    }
                    return undefined;
                }
            }).filter(change => !!change).sort((a, b) => b.timestamp - a.timestamp);
            this.savedChanges = changes;
        }
        async deleteChange(controlId, propertyName, fileName) {
            const filesToDelete = this.savedChanges.filter(change => fileName ? fileName === change.fileName : change.controlId === controlId && change.propertyName === propertyName).map(change => fetch(FlexChangesEndPoints.changes, {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ fileName: change.fileName })
            }));
            await Promise.all(filesToDelete).catch(error => Log.error(getError(error).message));
            await this.fetchSavedChanges();
            this.updateStack();
        }
        createOnStackChangeHandler() {
            const handleStackChange = modeAndStackChangeHandler(this.sendAction, this.options.rta);
            return async () => {
                const stack = this.options.rta.getCommandStack();
                const allCommands = stack.getCommands();
                const executedCommands = stack.getAllExecutedCommands();
                const inactiveCommandCount = allCommands.length - executedCommands.length;
                let activeChanges = [];
                allCommands.forEach((command, i) => {
                    try {
                        if (typeof command.getCommands === 'function') {
                            const subCommands = command.getCommands();
                            subCommands.forEach(subCommand => {
                                const pendingChange = this.prepareChangeType(subCommand, inactiveCommandCount, i);
                                if (pendingChange) {
                                    activeChanges.push(pendingChange);
                                }
                            });
                        } else {
                            const pendingChange = this.prepareChangeType(command, inactiveCommandCount, i);
                            if (pendingChange) {
                                activeChanges.push(pendingChange);
                            }
                        }
                    } catch (error) {
                        Log.error('CPE: Change creation Failed', getError(error));
                    }
                });
                activeChanges = activeChanges.filter(change => !!change);
                const changesRequiringReload = activeChanges.reduce((sum, change) => change.changeType === 'appdescr_fe_changePageConfiguration' ? sum + 1 : sum, 0);
                if (changesRequiringReload > this.changesRequiringReload) {
                    const resourceBundle = await getTextBundle();
                    MessageToast.show(resourceBundle.getText('CPE_CHANGES_VISIBLE_AFTER_SAVE_AND_RELOAD_MESSAGE'), { duration: 8000 });
                    this.sendAction(setApplicationRequiresReload(changesRequiringReload > 0));
                }
                this.changesRequiringReload = changesRequiringReload;
                if (Array.isArray(allCommands) && allCommands.length === 0) {
                    await this.fetchSavedChanges();
                }
                this.updateStack(activeChanges);
                handleStackChange();
            };
        }
        prepareChangeType(command, inactiveCommandCount, index) {
            let result;
            let value = '';
            const selectorId = this.getCommandSelectorId(command);
            const changeType = this.getCommandChangeType(command);
            if (!selectorId || !changeType) {
                return undefined;
            }
            switch (changeType) {
            case 'propertyChange':
                value = command.getProperty('newValue');
                break;
            case 'propertyBindingChange':
                value = command.getProperty('newBinding');
                break;
            }
            const {fileName} = command.getPreparedChange().getDefinition();
            if (changeType === 'propertyChange' || changeType === 'propertyBindingChange') {
                result = {
                    type: 'pending',
                    kind: 'property',
                    changeType,
                    controlId: selectorId,
                    propertyName: command.getProperty('propertyName'),
                    isActive: index >= inactiveCommandCount,
                    value,
                    controlName: command.getElement().getMetadata().getName().split('.').pop() ?? '',
                    fileName
                };
            } else {
                result = {
                    type: 'pending',
                    kind: 'unknown',
                    controlId: selectorId,
                    changeType,
                    isActive: index >= inactiveCommandCount,
                    controlName: changeType === 'addXMLAtExtensionPoint' ? command.getSelector().name ?? '' : command.getElement().getMetadata().getName().split('.').pop() ?? '',
                    fileName
                };
            }
            return result;
        }
        retryOperations(operations) {
            for (const operation of operations) {
                try {
                    const result = operation();
                    if (!result) {
                        continue;
                    }
                    return result;
                } catch (error) {
                    Log.error('Retry operation failed:', getError(error));
                    continue;
                }
            }
            return undefined;
        }
        getCommandChangeType(command) {
            return this.retryOperations([
                () => command.getChangeType(),
                () => command.getPreparedChange().getDefinition().changeType
            ]);
        }
        getCommandSelectorId(command) {
            return this.retryOperations([
                () => command.getSelector().id,
                () => command.getElement().getProperty('persistencyKey'),
                () => command.getElement().getId(),
                () => command.getParent()?.getElement().getId()
            ]);
        }
    }
    var __exports = { __esModule: true };
    __exports.ChangeService = ChangeService;
    return __exports;
});