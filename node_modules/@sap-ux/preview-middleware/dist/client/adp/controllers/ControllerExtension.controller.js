"use strict";

sap.ui.define(["sap/m/MessageToast", "sap/ui/core/library", "sap/ui/model/json/JSONModel", "../api-handler", "./BaseDialog.controller", "../utils"], function (MessageToast, sap_ui_core_library, JSONModel, ___api_handler, __BaseDialog, ___utils) {
  "use strict";

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule && typeof obj.default !== "undefined" ? obj.default : obj;
  }
  /** sap.ui.core */
  const ValueState = sap_ui_core_library["ValueState"];
  /** sap.ui.base */
  const getExistingController = ___api_handler["getExistingController"];
  const getManifestAppdescr = ___api_handler["getManifestAppdescr"];
  const readControllers = ___api_handler["readControllers"];
  const writeChange = ___api_handler["writeChange"];
  const writeController = ___api_handler["writeController"];
  const BaseDialog = _interopRequireDefault(__BaseDialog);
  const getControllerInfo = ___utils["getControllerInfo"];
  /**
   * @namespace open.ux.preview.client.adp.controllers
   */
  const ControllerExtension = BaseDialog.extend("open.ux.preview.client.adp.controllers.ControllerExtension", {
    constructor: function _constructor(name, overlays, rta) {
      BaseDialog.prototype.constructor.call(this, name);
      this.rta = rta;
      this.overlays = overlays;
      this.model = new JSONModel();
    },
    /**
     * Setups the Dialog and the JSON Model
     *
     * @param {Dialog} dialog - Dialog instance
     */
    setup: async function _setup(dialog) {
      this.dialog = dialog;
      this.setEscapeHandler();
      await this.buildDialogData();
      this.dialog.setModel(this.model);
      this.dialog.open();
    },
    /**
     * Handles fragment name input change
     *
     * @param event Event
     */
    onControllerNameInputChange: function _onControllerNameInputChange(event) {
      const input = event.getSource();
      const beginBtn = this.dialog.getBeginButton();
      const controllerName = input.getValue();
      const controllerList = this.model.getProperty('/controllersList');
      const updateDialogState = function (valueState) {
        let valueStateText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        input.setValueState(valueState).setValueStateText(valueStateText);
        beginBtn.setEnabled(valueState === ValueState.Success);
      };
      if (controllerName.length <= 0) {
        updateDialogState(ValueState.None);
        this.model.setProperty('/newControllerName', null);
        return;
      }
      const fileExists = controllerList.some(f => f.controllerName === `${controllerName}.js`);
      if (fileExists) {
        updateDialogState(ValueState.Error, 'Enter a different name. The controller name that you entered already exists in your project.');
        return;
      }
      const isValidName = /^[a-zA-Z_][a-zA-Z0-9_-]*$/.test(controllerName);
      if (!isValidName) {
        updateDialogState(ValueState.Error, 'The controller name cannot contain white spaces or special characters.');
        return;
      }
      if (controllerName.length > 64) {
        updateDialogState(ValueState.Error, 'A controller file name cannot contain more than 64 characters.');
        return;
      }
      updateDialogState(ValueState.Success);
      this.model.setProperty('/newControllerName', controllerName);
    },
    /**
     * Handles create button press
     *
     * @param event Event
     */
    onCreateBtnPress: async function _onCreateBtnPress(event) {
      const source = event.getSource();
      const controllerExists = this.model.getProperty('/controllerExists');
      if (!controllerExists) {
        source.setEnabled(false);
        const controllerName = this.model.getProperty('/newControllerName');
        const viewId = this.model.getProperty('/viewId');
        await this.createNewController(controllerName, viewId);
      } else {
        const controllerPath = this.model.getProperty('/controllerPath');
        window.open(`vscode://file${controllerPath}`);
      }
      this.handleDialogClose();
    },
    /**
     * Builds data that is used in the dialog.
     */
    buildDialogData: async function _buildDialogData() {
      const selectorId = this.overlays.getId();
      const overlayControl = sap.ui.getCore().byId(selectorId);
      const {
        controllerName,
        viewId
      } = getControllerInfo(overlayControl);
      const existingController = await this.getExistingController(controllerName);
      if (existingController) {
        const {
          controllerExists,
          controllerPath,
          controllerPathFromRoot,
          isRunningInBAS
        } = existingController;
        if (controllerExists) {
          this.updateModelForExistingController(controllerExists, controllerPath, controllerPathFromRoot, isRunningInBAS);
        } else {
          this.updateModelForNewController(viewId);
          await this.getControllers();
        }
      }
    },
    /**
     * Updates the model properties for an existing controller.
     *
     * @param {boolean} controllerExists - Whether the controller exists.
     * @param {string} controllerPath - The controller path.
     * @param {string} controllerPathFromRoot - The controller path from the project root.
     * @param {boolean} isRunningInBAS - Whether the environment is BAS or VS Code.
     */
    updateModelForExistingController: function _updateModelForExistingController(controllerExists, controllerPath, controllerPathFromRoot, isRunningInBAS) {
      this.model.setProperty('/controllerExists', controllerExists);
      this.model.setProperty('/controllerPath', controllerPath);
      this.model.setProperty('/controllerPathFromRoot', controllerPathFromRoot);
      const content = this.dialog.getContent();
      const form = content[0];
      form.setVisible(false);
      const messageForm = content[1];
      messageForm.setVisible(true);
      if (isRunningInBAS) {
        this.dialog.getBeginButton().setVisible(false);
      } else {
        this.dialog.getBeginButton().setText('Open in VS Code').setEnabled(true);
      }
      this.dialog.getEndButton().setText('Close');
    },
    /**
     * Updates the model property for a new controller.
     *
     * @param viewId The view ID
     */
    updateModelForNewController: function _updateModelForNewController(viewId) {
      this.model.setProperty('/viewId', viewId);
    },
    /**
     * Retrieves existing controller data if found in the project's workspace.
     *
     * @param controllerName Controller name that exists in the view
     * @returns Returnsexisting controller data
     */
    getExistingController: async function _getExistingController(controllerName) {
      let data;
      try {
        data = await getExistingController(controllerName);
      } catch (e) {
        this.handleError(e);
      }
      return data;
    },
    /**
     * Retrieves controller files and fills the model with data
     */
    getControllers: async function _getControllers() {
      try {
        const {
          controllers
        } = await readControllers();
        this.model.setProperty('/controllersList', controllers);
      } catch (e) {
        this.handleError(e);
      }
    },
    /**
     * Creates a new fragment for the specified control
     *
     * @param controllerName Controller Name
     * @param viewId View Id
     */
    createNewController: async function _createNewController(controllerName, viewId) {
      try {
        const manifest = await getManifestAppdescr();
        await writeController({
          controllerName,
          projectId: manifest.id
        });
        const controllerRef = {
          codeRef: `coding/${controllerName}.js`,
          viewId
        };
        const service = await this.rta.getService('controllerExtension');
        const change = await service.add(controllerRef.codeRef, controllerRef.viewId);
        change.creation = new Date().toISOString();
        await writeChange(change);
        MessageToast.show(`Controller extension with name '${controllerName}' was created.`);
      } catch (e) {
        // We want to update the model incase we have already created a controller file but failed when creating a change file,
        // so when the user types the same controller name again he does not get 409 from the server, instead an error is shown in the UI
        await this.getControllers();
        this.handleError(e);
      }
    }
  });
  return ControllerExtension;
});
//# sourceMappingURL=ControllerExtension.controller.js.map